#pragma semicolon 1
#pragma newdecls required

static const char PistolFire[][] =
{
	"weapons/pistol/pistol_fire2.wav"
};

static const char PistolReload[][] =
{
	"weapons/pistol/pistol_reload1.wav"
};

static const char StunStickDeploy[][] =
{
	"weapons/stunstick/spark1.wav",
	"weapons/stunstick/spark2.wav",
	"weapons/stunstick/spark3.wav"
};

static const char StunStickHit[][] =
{
	"weapons/stunstick/stunstick_fleshhit1.wav",
	"weapons/stunstick/stunstick_fleshhit2.wav"
};

static const char StunStickFire[][] =
{
	"weapons/stunstick/stunstick_swing1.wav",
	"weapons/stunstick/stunstick_swing2.wav"
};

static const char SMGFire[][] =
{
	"weapons/smg1/smg1_fire1.wav"
};

static const char SMGReload[][] =
{
	"weapons/smg1/smg1_reload.wav"
};

static const char FistHit[][] =
{
	"npc/vort/foot_hit.wav",
};

static const char FistFire[][] =
{
	"npc/combine_soldier/gear1.wav",
	"npc/combine_soldier/gear2.wav",
	"npc/combine_soldier/gear3.wav",
	"npc/combine_soldier/gear4.wav",
	"npc/combine_soldier/gear5.wav",
	"npc/combine_soldier/gear6.wav"
};

static const char AR2Fire[][] =
{
	"weapons/ar2/fire1.wav"
};

static const char AR2Reload[][] =
{
	"weapons/ar2/npc_ar2_reload.wav"
};

static const char AR2Special[][] =
{
	"weapons/irifle/irifle_fire2.wav",
};

static const char ShotgunFire[][] =
{
	"weapons/shotgun/shotgun_fire6.wav",
	"weapons/shotgun/shotgun_fire7.wav"
};

static const char ShotgunReload[][] =
{
	"weapons/shotgun/shotgun_reload1.wav",
	"weapons/shotgun/shotgun_reload2.wav",
	"weapons/shotgun/shotgun_reload3.wav"
};

static const char SwordDeploy[][] =
{
	"weapons/medi_shield_deploy.wav"
};

static const char SwordHit[][] =
{
	"weapons/halloween_boss/knight_axe_hit.wav"
};

static const char SwordFire[][] =
{
	"weapons/demo_sword_swing1.wav",
	"weapons/demo_sword_swing2.wav",
	"weapons/demo_sword_swing3.wav"
};

static const char SwordSpecial[][] =
{
	"weapons/physcannon/energy_sing_explosion2.wav"
};

static const char Overload[][] =
{
	"ambient_mp3/halloween/thunder_01.mp3",
	"ambient_mp3/halloween/thunder_04.mp3",
	"ambient_mp3/halloween/thunder_06.mp3"
};

static const char PoliceIdle[][] =
{
	"npc/metropolice/vo/catchthatbliponstabilization.wav",
	"npc/metropolice/vo/clearandcode100.wav",
	"npc/metropolice/vo/clearno647no10-107.wav",
	"npc/metropolice/vo/control100percent.wav",
	"npc/metropolice/vo/wearesociostablethislocation.wav"
};

static const char PoliceIdleAlert[][] =
{
	"npc/metropolice/vo/airwatchsubjectis505.wav",
	"npc/metropolice/vo/allunitscloseonsuspect.wav",
	"npc/metropolice/vo/allunitsmovein.wav",
	"npc/metropolice/vo/breakhiscover.wav",
	"npc/metropolice/vo/destroythatcover.wav"
};

static const char PoliceHurt[][] =
{
	"npc/metropolice/pain1.wav",
	"npc/metropolice/pain2.wav",
	"npc/metropolice/pain3.wav",
	"npc/metropolice/pain4.wav"
};

static const char PolicePanic[][] =
{
	"npc/metropolice/vo/officerdowncode3tomy10-20.wav",
	"npc/metropolice/vo/officerdowniam10-99.wav",
	"npc/metropolice/vo/officerneedsassistance.wav",
	"npc/metropolice/vo/officerneedsassistance.wav",
	"npc/metropolice/vo/officerneedshelp.wav"
};

static const char PoliceDeath[][] =
{
	"npc/metropolice/die1.wav",
	"npc/metropolice/die2.wav",
	"npc/metropolice/die3.wav",
	"npc/metropolice/die4.wav"
};

static const char SoldierIdle[][] =
{
	"npc/combine_soldier/vo/copythat.wav",
	"npc/combine_soldier/vo/hardenthatposition.wav",
	"npc/combine_soldier/vo/motioncheckallradials.wav",
	"npc/combine_soldier/vo/overwatchreportspossiblehostiles.wav",
	"npc/combine_soldier/vo/prepforcontact.wav",
	"npc/combine_soldier/vo/readyweaponshostilesinbound.wav",
	"npc/combine_soldier/vo/reportingclear.wav",
	"npc/combine_soldier/vo/sectorissecurenovison.wav",
	"npc/combine_soldier/vo/sightlineisclear.wav",
	"npc/combine_soldier/vo/standingby].wav",
	"npc/combine_soldier/vo/stayalertreportsightlines.wav"
};

static const char SoldierIdleAlert[][] =
{
	"npc/combine_soldier/vo/bouncerbouncer.wav",
	"npc/combine_soldier/vo/contactconfim.wav",
	"npc/combine_soldier/vo/engaging.wav",
	"npc/combine_soldier/vo/suppressing.wav",
	"npc/combine_soldier/vo/targetmyradial.wav"
};

static const char SoldierDeath[][] =
{
	"npc/combine_soldier/die1.wav",
	"npc/combine_soldier/die2.wav",
	"npc/combine_soldier/die3.wav"
};

static const char SoldierHurt[][] =
{
	"npc/combine_soldier/die1.wav",
	"npc/combine_soldier/die2.wav",
	"npc/combine_soldier/die3.wav"
};

static const char SoldierSpecial[][] =
{
	"npc/combine_soldier/vo/targetcompromisedmovein.wav"
};

static const char SwordsmanIdle[][] =
{
	"npc/combine_soldier/vo/blade.wav",
	"npc/combine_soldier/vo/dagger.wav",
	"npc/combine_soldier/vo/fist.wav",
	"npc/combine_soldier/vo/hammer.wav",
	"npc/combine_soldier/vo/razor.wav",
	"npc/combine_soldier/vo/spear.wav",
	"npc/combine_soldier/vo/sword.wav"
};

static const char SwordsmanIdleAlert[][] =
{
	"npc/combine_soldier/vo/displace.wav",
	"npc/combine_soldier/vo/displace2.wav",
	"npc/combine_soldier/vo/gosharp.wav",
	"npc/combine_soldier/vo/gosharpgosharp.wav",
	"npc/combine_soldier/vo/sharpzone.wav",
	"npc/combine_soldier/vo/sweepingin.wav",
	"npc/combine_soldier/vo/thatsitwrapitup.wav"
};

static int DeathDamage[MAXENTITIES];
static int CCFlags[MAXENTITIES];

void BaseSquad_MapStart()
{
	PrecacheSoundArray(PistolFire);
	PrecacheSoundArray(PistolReload);
	PrecacheSoundArray(StunStickDeploy);
	PrecacheSoundArray(StunStickHit);
	PrecacheSoundArray(StunStickFire);
	PrecacheSoundArray(SMGFire);
	PrecacheSoundArray(SMGReload);
	PrecacheSoundArray(FistHit);
	PrecacheSoundArray(FistFire);
	PrecacheSoundArray(AR2Fire);
	PrecacheSoundArray(AR2Reload);
	PrecacheSoundArray(AR2Special);
	PrecacheSoundArray(ShotgunFire);
	PrecacheSoundArray(ShotgunReload);
	PrecacheSoundArray(SwordDeploy);
	PrecacheSoundArray(SwordHit);
	PrecacheSoundArray(SwordFire);
	PrecacheSoundArray(SwordSpecial);
	PrecacheSoundArray(Overload);

	PrecacheSoundArray(PoliceIdle);
	PrecacheSoundArray(PoliceIdleAlert);
	PrecacheSoundArray(PoliceHurt);
	PrecacheSoundArray(PoliceDeath);
	PrecacheSoundArray(PolicePanic);
	PrecacheSoundArray(SoldierIdle);
	PrecacheSoundArray(SoldierIdleAlert);
	PrecacheSoundArray(SoldierHurt);
	PrecacheSoundArray(SoldierDeath);
	PrecacheSoundArray(SoldierSpecial);
	PrecacheSoundArray(SwordsmanIdle);
	PrecacheSoundArray(SwordsmanIdleAlert);
	
	PrecacheModel("models/police.mdl");
	PrecacheModel("models/combine_soldier.mdl");
	PrecacheModel("models/combine_super_soldier.mdl");
	PrecacheModel("models/weapons/w_grenade.mdl");
	PrecacheModel("models/effects/combineball.mdl");

	PrecacheModel("models/humans/group03/male_01_bloody.mdl");
	PrecacheModel("models/humans/group03/male_02_bloody.mdl");
	PrecacheModel("models/humans/group03/male_03_bloody.mdl");
	PrecacheModel("models/humans/group03/male_04_bloody.mdl");
	PrecacheModel("models/humans/group03/male_05_bloody.mdl");
	PrecacheModel("models/humans/group03/male_06_bloody.mdl");
	PrecacheModel("models/humans/group03/male_07_bloody.mdl");
	PrecacheModel("models/humans/group03/male_08_bloody.mdl");
	PrecacheModel("models/humans/group03/male_09_bloody.mdl");
	PrecacheModel("models/humans/group03/female_01_bloody.mdl");
	PrecacheModel("models/humans/group03/female_02_bloody.mdl");
	PrecacheModel("models/humans/group03/female_03_bloody.mdl");
	PrecacheModel("models/humans/group03/female_05_bloody.mdl");
	PrecacheModel("models/humans/group03/female_06_bloody.mdl");
	PrecacheModel("models/humans/group03/female_07_bloody.mdl");
}

methodmap BaseSquad < CClotBody
{
	public void PlayPistolFire()
	{
		EmitSoundToAll(PistolFire[GetURandomInt() % sizeof(PistolFire)], this.index, _, 94);
	}
	public void PlayPistolReload()
	{
		EmitSoundToAll(PistolReload[GetURandomInt() % sizeof(PistolReload)], this.index, _, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlayStunStickDeploy()
	{
		EmitSoundToAll(StunStickDeploy[GetURandomInt() % sizeof(StunStickDeploy)], this.index, _, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlayStunStickFire()
	{
		EmitSoundToAll(StunStickFire[GetURandomInt() % sizeof(StunStickFire)], this.index, _, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlayStunStickHit()
	{
		EmitSoundToAll(StunStickHit[GetURandomInt() % sizeof(StunStickHit)], this.index, _, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlaySMGFire()
	{
		EmitSoundToAll(SMGFire[GetURandomInt() % sizeof(SMGFire)], this.index, _, 94);
	}
	public void PlaySMGReload()
	{
		EmitSoundToAll(SMGReload[GetURandomInt() % sizeof(SMGReload)], this.index, _, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlayFistHit()
	{
		EmitSoundToAll(FistHit[GetURandomInt() % sizeof(FistHit)], this.index, _, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlayFistFire()
	{
		EmitSoundToAll(FistFire[GetURandomInt() % sizeof(FistFire)], this.index, _, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlayAR2Fire()
	{
		EmitSoundToAll(AR2Fire[GetURandomInt() % sizeof(AR2Fire)], this.index, _, 94);
	}
	public void PlayAR2Reload()
	{
		EmitSoundToAll(AR2Reload[GetURandomInt() % sizeof(AR2Reload)], this.index, _, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlayAR2Special()
	{
		EmitSoundToAll(AR2Special[GetURandomInt() % sizeof(AR2Special)], this.index, _, 94);
	}
	public void PlayShotgunFire()
	{
		EmitSoundToAll(ShotgunFire[GetURandomInt() % sizeof(ShotgunFire)], this.index, _, 94);
	}
	public void PlayShotgunReload()
	{
		EmitSoundToAll(ShotgunReload[GetURandomInt() % sizeof(ShotgunReload)], this.index, _, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlaySwordDeploy()
	{
		EmitSoundToAll(SwordDeploy[GetURandomInt() % sizeof(SwordDeploy)], this.index, _, 94);
	}
	public void PlaySwordFire()
	{
		EmitSoundToAll(SwordFire[GetURandomInt() % sizeof(SwordFire)], this.index, _, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlaySwordHit()
	{
		EmitSoundToAll(SwordHit[GetURandomInt() % sizeof(SwordHit)], this.index, _, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlaySwordSpecial()
	{
		EmitSoundToAll(SwordSpecial[GetURandomInt() % sizeof(SwordSpecial)], this.index, _, 94);
	}
	public void PlayOverload()
	{
		int rand = GetURandomInt() % sizeof(Overload);
		EmitSoundToAll(Overload[rand], this.index, _, 94);
		EmitSoundToAll(Overload[rand], this.index, _, 94);
	}
	public BaseSquad(float vecPos[3], float vecAng[3],
						const char[] model,
						const char[] modelscale = "1.0",
						bool Ally = false,
						bool Ally_Invince = false,
						bool isGiant = false,
						bool IgnoreBuildings = false,
						bool IsRaidBoss = false,
						const float CustomThreeDimensions[3] = {0.0,0.0,0.0},
						bool Ally_Collideeachother = false)
	{
		BaseSquad npc = view_as<BaseSquad>(CClotBody(vecPos, vecAng, model, modelscale, _, Ally, Ally_Invince, isGiant, IgnoreBuildings, IsRaidBoss, CustomThreeDimensions, Ally_Collideeachother));

		f3_SpawnPosition[npc.index][0] = vecPos[0];
		f3_SpawnPosition[npc.index][1] = vecPos[1];
		f3_SpawnPosition[npc.index][2] = vecPos[2];

		npc.SetActivity("ACT_IDLE");
		if(npc.LookupActivity("ACT_LAND") > 0)
			npc.AddGesture("ACT_LAND");

		npc.m_bAnger = false;
		npc.m_iTargetAttack = 0;
		npc.m_iTargetWalk = 0;
		npc.m_iDeathDamage = 1;
		npc.m_iNoTargetCount = 0;
		npc.m_flNextIdleSound = 0.0;
		npc.m_flNextIdleAlertSound = 0.0;
		npc.m_hCCFlags = 0;
		//npc.m_flSpeed = 600.0;

		//npc.SetGoalEntity(vecPos);
		//npc.StartPathing();
		return npc;
	}
	public void UpdateHealthBar()
	{
		if(IsValidEntity(this.m_iTextEntity3))
		{
			char string[32];
			Format(string, sizeof(string), "%d / %d", GetEntProp(this.index, Prop_Data, "m_iHealth"), GetEntProp(this.index, Prop_Data, "m_iMaxHealth"));
			DispatchKeyValue(this.m_iTextEntity3, "message", string);
		}
	}
	property bool m_bIsSquad
	{
		public get()		{ return this.m_iDeathDamage && !NpcStats_IsEnemySilenced(this.index); }
	}
	property bool m_bAnger
	{
		public get()		{ return this.Anger; }
		public set(bool value) 	{ this.Anger = value; }
	}
	property bool m_bRanged
	{
		public get()		{ return this.m_fbGunout; }
		public set(bool value) 	{ this.m_fbGunout = value; }
	}
	property int m_iTargetAttack
	{
		public get()		{ return this.m_iTarget; }
		public set(int value) 	{ this.m_iTarget = value; }
	}
	property int m_iTargetWalk
	{
		public get()		{ return this.m_iTargetAlly; }
		public set(int value) 	{ this.m_iTargetAlly = value; }
	}
	property int m_iDeathDamage
	{
		public get()		{ return DeathDamage[this.index]; }
		public set(int value) 	{ DeathDamage[this.index] = value; }
	}
	property int m_iNoTargetCount
	{
		public get()		{ return i_NoEntityFoundCount[this.index]; }
		public set(int value) 	{ i_NoEntityFoundCount[this.index] = value; }
	}
	property float m_flNextIdleAlertSound
	{
		public get()		{ return this.m_flRangedSpecialDelay; }
		public set(float value)	{ this.m_flRangedSpecialDelay = value; }
	}
	property int m_hCCFlags
	{
		public get()		{ return CCFlags[this.index]; }
		public set(int value) 	{ CCFlags[this.index] = value; }
	}
}

methodmap CombinePolice < BaseSquad
{
	public void PlayIdle(bool anger)
	{
		float gameTime = GetGameTime(this.index);

		if(anger)
		{
			if(this.m_flNextIdleAlertSound > gameTime)
				return;
			
			EmitSoundToAll(PoliceIdleAlert[GetURandomInt() % sizeof(PoliceIdleAlert)], this.index, SNDCHAN_VOICE, BOSS_ZOMBIE_SOUNDLEVEL);
			this.m_flNextIdleAlertSound = gameTime + GetRandomFloat(12.0, 24.0);
		}
		else
		{
			if(this.m_flNextIdleSound > gameTime)
				return;
			
			EmitSoundToAll(PoliceIdle[GetURandomInt() % sizeof(PoliceIdle)], this.index, SNDCHAN_VOICE, BOSS_ZOMBIE_SOUNDLEVEL);
			this.m_flNextIdleSound = gameTime + GetRandomFloat(12.0, 24.0);
		}
	}
	public void PlayHurt()
	{
		EmitSoundToAll(PoliceHurt[GetURandomInt() % sizeof(PoliceHurt)], this.index, SNDCHAN_VOICE, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlayDeath()
	{
		EmitSoundToAll(PoliceDeath[GetURandomInt() % sizeof(PoliceDeath)], this.index, SNDCHAN_VOICE, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlayPanic()
	{
		EmitSoundToAll(PolicePanic[GetURandomInt() % sizeof(PolicePanic)], this.index, SNDCHAN_VOICE, BOSS_ZOMBIE_SOUNDLEVEL);
	}
}

methodmap CombineSoldier < BaseSquad
{
	public void PlayIdle(bool anger)
	{
		float gameTime = GetGameTime(this.index);

		if(anger)
		{
			if(this.m_flNextIdleAlertSound > gameTime)
				return;
			
			EmitSoundToAll(SoldierIdleAlert[GetURandomInt() % sizeof(SoldierIdleAlert)], this.index, SNDCHAN_VOICE, BOSS_ZOMBIE_SOUNDLEVEL);
			this.m_flNextIdleAlertSound = gameTime + GetRandomFloat(12.0, 24.0);
		}
		else
		{
			if(this.m_flNextIdleSound > gameTime)
				return;
			
			EmitSoundToAll(SoldierIdle[GetURandomInt() % sizeof(SoldierIdle)], this.index, SNDCHAN_VOICE, BOSS_ZOMBIE_SOUNDLEVEL);
			this.m_flNextIdleSound = gameTime + GetRandomFloat(12.0, 24.0);
		}
	}
	public void PlayHurt()
	{
		EmitSoundToAll(SoldierHurt[GetURandomInt() % sizeof(SoldierHurt)], this.index, SNDCHAN_VOICE, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlayDeath()
	{
		EmitSoundToAll(PoliceDeath[GetURandomInt() % sizeof(PoliceDeath)], this.index, SNDCHAN_VOICE, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlaySpecial()
	{
		EmitSoundToAll(SoldierSpecial[GetURandomInt() % sizeof(SoldierSpecial)], this.index, SNDCHAN_VOICE, BOSS_ZOMBIE_SOUNDLEVEL);
	}
}

methodmap CombineWarrior < BaseSquad
{
	public void PlayIdle(bool anger)
	{
		float gameTime = GetGameTime(this.index);

		if(anger)
		{
			if(this.m_flNextIdleAlertSound > gameTime)
				return;
			
			EmitSoundToAll(SwordsmanIdleAlert[GetURandomInt() % sizeof(SwordsmanIdleAlert)], this.index, SNDCHAN_VOICE, BOSS_ZOMBIE_SOUNDLEVEL);
			this.m_flNextIdleAlertSound = gameTime + GetRandomFloat(12.0, 24.0);
		}
		else
		{
			if(this.m_flNextIdleSound > gameTime)
				return;
			
			EmitSoundToAll(SwordsmanIdle[GetURandomInt() % sizeof(SwordsmanIdle)], this.index, SNDCHAN_VOICE, BOSS_ZOMBIE_SOUNDLEVEL);
			this.m_flNextIdleSound = gameTime + GetRandomFloat(4.0, 6.0);
		}
	}
	public void PlayHurt()
	{
		EmitSoundToAll(SoldierHurt[GetURandomInt() % sizeof(SoldierHurt)], this.index, SNDCHAN_VOICE, BOSS_ZOMBIE_SOUNDLEVEL);
	}
	public void PlayDeath()
	{
		EmitSoundToAll(SoldierDeath[GetURandomInt() % sizeof(SoldierDeath)], this.index, SNDCHAN_VOICE, BOSS_ZOMBIE_SOUNDLEVEL);
	}
}

bool BaseSquad_InFireRange(float eyePitch, float vecDir)
{
	float sub = fabs(fixAngle(eyePitch)) - fabs(fixAngle(vecDir));
	return (sub > -12.5 && sub < 12.5);
}

static bool InVisionRange(const float vecMe[3], BaseSquad npc, int enemy)
{
	float eyePitch[3], vecTarget[3], vecDir[3];
	GetEntPropVector(npc.index, Prop_Data, "m_angRotation", eyePitch);
	vecTarget = WorldSpaceCenterOld(enemy);

	MakeVectorFromPoints(vecMe, vecTarget, vecDir);
	GetVectorAngles(vecDir, vecDir);

	float sub = fabs(fixAngle(eyePitch[1])) - fabs(fixAngle(vecDir[1]));
	return (sub > -60.0 && sub < 60.0);
}

void BaseSquad_BaseThinking(any npcIndex, const float vecMe[3], bool ignoreLOS = false)
{
	BaseSquad npc = view_as<BaseSquad>(npcIndex);

	float gameTime = GetGameTime(npc.index);
	float gameRealTime = GetGameTime();

	if(npc.m_iTargetAttack && !IsValidEnemy(npc.index, npc.m_iTargetAttack))
	{
		npc.m_iTargetAttack = 0;
		npc.m_flGetClosestTargetTime = 0.0;
		if(npc.m_iTargetAttack == i_NpcFightOwner[npc.index])
			i_NpcFightOwner[npc.index] = 0;
	}
	else if(i_NpcFightOwner[npc.index] && f_NpcFightTime[npc.index] > gameRealTime)
	{
		npc.m_flGetClosestTargetTime = 0.0;
	}

	if(npc.m_iTargetWalk && !IsEntityAlive(npc.m_iTargetAttack))
	{
		npc.m_iTargetWalk = 0;
		//npc.m_flGetClosestTargetTime = 0.0;
	}
	
	if(npc.m_flGetClosestTargetTime < gameTime)
	{
		npc.m_flGetClosestTargetTime = gameTime + 1.0;

		float distance = b_NpcIsInADungeon[npc.index] ? 99999.9 : (npc.m_iTargetAttack ? 800.0 : 500.0);
		
		float vecTarget[3];
		
		// We constantly target who attacked us
		if(b_NpcIsInADungeon[npc.index] || !npc.m_iTargetAttack || !npc.m_iTargetWalk || !i_NpcFightOwner[npc.index] || f_NpcFightTime[npc.index] < gameRealTime)
		{
			npc.m_iTargetAttack = 0;
			npc.m_iTargetWalk = 0;

			if(!b_NpcIsInADungeon[npc.index] && i_NpcFightOwner[npc.index] && f_NpcFightTime[npc.index] > gameRealTime && IsValidEnemy(npc.index, i_NpcFightOwner[npc.index]))
			{
				npc.m_iTargetAttack = i_NpcFightOwner[npc.index];
				npc.m_iTargetWalk = npc.m_iTargetAttack;
			}
			else
			{
				int target = GetClosestTarget(npc.index, false, distance);
				if(target > 0 && (b_NpcIsInADungeon[npc.index] || (Can_I_See_Enemy(npc.index, target) && (ignoreLOS || InVisionRange(vecMe, npc, target)))))
				{
					npc.m_iTargetAttack = target;
					npc.m_iTargetWalk = npc.m_iTargetAttack;
				}
				else
				{
					bool friendly = GetEntProp(npc.index, Prop_Send, "m_iTeamNum") == 2;
					int count = friendly ? i_MaxcountNpc_Allied : i_MaxcountNpc;

					// Ask our squad members if they can see them
					for(int i; i < count; i++)
					{
						BaseSquad ally = view_as<BaseSquad>(EntRefToEntIndex(friendly ? i_ObjectsNpcs_Allied[i] : i_ObjectsNpcs[i]));
						if(ally.index != -1 && ally.index != npc.index)
						{
							if(ally.m_bIsSquad && ally.m_iTargetAttack && IsValidEnemy(npc.index, ally.m_iTargetAttack) && Can_I_See_Enemy(ally.index, ally.m_iTargetAttack))
							{
								vecTarget = WorldSpaceCenterOld(ally.index);
								if(GetVectorDistance(vecMe, vecTarget, true) < 250000.0)	// 500 HU
								{
									npc.m_iTargetAttack = ally.m_iTargetAttack;
									npc.m_iTargetWalk = ally.m_iTargetAttack;
									break;
								}
							}
						}
					}
				}
			}
		}

		// We can't run after them, stand still and do shooty logic
		if(npc.m_iTargetWalk)
		{
			float length;
			if(!(GetEntityFlags(npc.index) & (FL_SWIM|FL_INWATER))/* && PF_IsPathToEntityPossible(npc.index, npc.m_iTargetWalk, length)*/)
			{
				// Players can be above a nav mesh and a "path" is possible
				// Check if the target is above a place

				vecTarget = WorldSpaceCenterOld(npc.m_iTargetWalk);
				distance = vecTarget[2] - vecMe[2];
				if(distance > 100.0 || (distance > 15.0 && distance > length))
					npc.m_iTargetWalk = 0;
			}
			else
			{
				npc.m_iTargetWalk = 0;
			}
		}
	}
}

void BaseSquad_BaseWalking(any npcIndex, const float vecMe[3], bool predict = false, bool teleport = false)
{
	BaseSquad npc = view_as<BaseSquad>(npcIndex);

	if(GetEntityFlags(npc.index) & (FL_SWIM|FL_INWATER))
	{
		TeleportEntity(npc.index, f3_SpawnPosition[npc.index]);
	}
	else if(npc.m_iTargetWalk || npc.m_iTargetAttack)
	{
		npc.m_iNoTargetCount = 0;
		
		if(npc.m_iTargetWalk)
		{
			if(predict)
			{
				float vecTarget[3];
				vecTarget = WorldSpaceCenterOld(npc.m_iTargetWalk);

				if(GetVectorDistance(vecTarget, vecMe, true) < npc.GetLeadRadius())
				{
					vecTarget = PredictSubjectPositionOld(npc, npc.m_iTargetWalk);
					npc.SetGoalVector(vecTarget);
				}
				else
				{
					npc.SetGoalEntity(npc.m_iTargetWalk);
				}
			}
			else
			{
				npc.SetGoalEntity(npc.m_iTargetWalk);
			}

			npc.StartPathing();
		}
		else
		{
			npc.StopPathing();
		}
	}
	else if(++npc.m_iNoTargetCount > (teleport ? 49 : 19))
	{
		if(teleport && GetVectorDistance(vecMe, f3_SpawnPosition[npc.index], true) > 25000.0)	// 158 HU
		{
			TeleportEntity(npc.index, f3_SpawnPosition[npc.index]);
		}
		else if(GetVectorDistance(vecMe, f3_SpawnPosition[npc.index], true) > 8000.0)	// 90 HU
		{
			npc.SetGoalVector(f3_SpawnPosition[npc.index]);
			npc.StartPathing();
		}
		else
		{
			int maxhealth = ReturnEntityMaxHealth(npc.index);
			int health = GetEntProp(npc.index, Prop_Data, "m_iHealth");

			if(health < maxhealth)
			{
				health += maxhealth / 50;
				if(health > maxhealth)
					health = maxhealth;
				
				SetEntProp(npc.index, Prop_Data, "m_iHealth", health);
				npc.UpdateHealthBar();
			}

			if(npc.m_flMeleeArmor > 0.5)
			{
				npc.m_flMeleeArmor -= 0.025;
				if(npc.m_flMeleeArmor < 0.5)
					npc.m_flMeleeArmor = 0.5;
			}

			if(npc.m_flRangedArmor > 0.5)
			{
				npc.m_flRangedArmor -= 0.025;
				if(npc.m_flRangedArmor < 0.5)
					npc.m_flRangedArmor = 0.5;
			}

			npc.StopPathing();
		}
	}
	else
	{
		npc.StopPathing();
	}
}

bool BaseSquad_BaseAnim(any npcIndex, float speedPassive, const char[] idlePassive, const char[] walkPassive, float speedAnger = 0.0, const char[] idleAnger = "", const char[] walkAnger = "")
{
	BaseSquad npc = view_as<BaseSquad>(npcIndex);

	bool anger;
	if(npc.m_bPathing)
	{
		if(walkAnger[0] && npc.m_iNoTargetCount < 20)
		{
			npc.m_flSpeed = speedAnger;
			npc.SetActivity(walkAnger);
			anger = true;
		}
		else
		{
			npc.m_flSpeed = speedPassive;
			npc.SetActivity(walkPassive);
		}
	}
	else
	{
		npc.m_flSpeed = 0.0;

		if(idleAnger[0] && npc.m_iNoTargetCount < 20)
		{
			npc.SetActivity(idleAnger);
			anger = true;
		}
		else
		{
			npc.SetActivity(idlePassive);
		}
	}

	return anger;
}

public Action BaseSquad_TakeDamage(int victim, int &attacker, int &inflictor, float &damage, int &damagetype, int &weapon, float damageForce[3], float damagePosition[3], int damagecustom)
{
	//Valid attackers only.
	if(attacker < 1)
		return Plugin_Continue;

	BaseSquad npc = view_as<BaseSquad>(victim);

	if(damagetype & DMG_CLUB)
	{
		if(npc.m_flMeleeArmor < 1.5)
		{
			EmitSoundToAll("physics/metal/metal_box_impact_bullet1.wav", victim, SNDCHAN_STATIC, BOSS_ZOMBIE_SOUNDLEVEL, _, BOSS_ZOMBIE_VOLUME);

			npc.m_flMeleeArmor += 0.25001;
			if(npc.m_flMeleeArmor > 1.5)
				npc.m_flMeleeArmor = 1.5;
		}
	}
	else if(!(damagetype & DMG_TRUEDAMAGE))
	{
		if(npc.m_flRangedArmor < 1.5)
		{
			EmitSoundToAll("physics/metal/metal_box_impact_bullet1.wav", victim, SNDCHAN_STATIC, BOSS_ZOMBIE_SOUNDLEVEL, _, BOSS_ZOMBIE_VOLUME);

			npc.m_flRangedArmor += 0.10001;
			if(npc.m_flRangedArmor > 1.5)
				npc.m_flRangedArmor = 1.5;
		}
	}

	float gameTime = GetGameTime(npc.index);
	if(npc.m_flHeadshotCooldown < gameTime)
	{
		npc.m_flHeadshotCooldown = gameTime + DEFAULT_HURTDELAY;
		npc.m_blPlayHurtAnimation = true;
	}
	return Plugin_Changed;
}

public void Dungeon_CombineSuperArmor(int entity)
{
	if(i_NpcInternalId[entity] != COMBINE_GIANT)
	{
		BaseSquad npc = view_as<BaseSquad>(entity);
		if(npc.m_bIsSquad)
		{
			npc.m_flMeleeArmor = 0.0001;
			npc.m_flRangedArmor = 0.0001;
		}
	}
}